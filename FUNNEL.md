CandyShop is a service that allows users to convert "**right to extract value**" to **value**. We are a smart transaction batching service that extracts value by controlling transaction ordering.

Right now every user sends a transaction directly to the network mempool and thus give away the arbitrage, front-running, back-running opportunities to miners(or random bots). **We create a virtual mempool that waits for an interval before sending a single transaction on-chain that performs all the actions for the users**. Actions include DEX trades, interactions with lending protocols, oracle updates and so on...

We are a relayer at worst and a efficient transaction ordering service at best

## Efficiency by Aggregation

Batching is a popular scaling approach taken by several projects to do [airdrops](https://multisender.app/), [token transfers out of exchanges](https://blog.coinbase.com/reflections-on-bitcoin-transaction-batching-b13dad12a12) nd other applications.

Let's see what we can do in the current world if we have batching or have access to trades before they hit the network.

1. Save 21k base gas cost on every transaction

1. [Backrun user DEX trades](https://medium.com/@vaibhavchellani223/welcome-to-the-candyshop-6c3e8f48bf2)
1. Backrun oracle updates (CDP saver as a service)
1. P2P match orders to save the need to settle on actual AMM
1. [Gnosis Ring Trades](https://blog.gnosis.pm/announcing-the-gnosis-protocol-89b3d7794da7)
1. Order trades in different directions sequentially to produce positive slippage.
1. [Add up smaller trades in the same direction](https://ethresear.ch/t/pessimistic-rollup-scalable-batched-smart-contract-interactions/7765)
1. Flash loan and become AMM LP before batch to capture trading fees
1. Removes the need of arbitrage, back-running bots participating in **Priority Gas Auctions** thus keeping the network usable for others.
1. Meta-Tx built in
1. Better UX, no need to do `approve` and `transferFrom`
1. Works as `sequencers` for upcoming L2 solutions like [optimism](https://optimism.io/) and others.
1. Scalable governance by collecting signatures off-chain and doing one transaction on-chain from the super-wallet.

> **If we have access to transactions before the network we can generate value because we can calculate future state off-chain**

We can extract some MEV at the application layer and use that to make DEX trades `more efficient` and reduce `impermanent_loss` for AMM liquidity providers.

## User Capture

The whole point of CandyShop is to maximize profits from user actions which gets distributed for free to miners and bots. We intent to extract this value and provide these profits as `**cashback**` to users.

**For example**: A uniswap trader who loses `X%` to slippage during his trade can now get `X-Y %` slippage on his trade, because we were able to backrun his trade and give him the arbitrage profits.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ab408011-375c-4498-b849-fc8d4d2bac1b/Picture_1.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ab408011-375c-4498-b849-fc8d4d2bac1b/Picture_1.jpg)

CandyShop gets better and better as more transactions flow because the `prenotion` of global state gets better and better.

We can create `Application Specific MEV Strategies` and use those to extract MEV on the application layer for public blockchains like Ethereum.

## What if someone frontruns the candyshop relayer?

When a user interacts with candyshop he signs an order which looks something like this

```jsx
order = {
	Give: ETH,
	Want: DAI,
	SlippageLimit: 10%,
	Amount: 1000ETH,
	Relayer: 0xabc...,
	FeesIn: DAI,
	TargetDEX: Uniswap,
	Deadline: time.Now() + 1*time.Minute
	Signature: sign(order.SignBytes())
}
```

Now if the relayer broadcasts this transaction with a arbitrage order the transaction contains 2 orders:

```jsx
transactions = [
	{
		Give: ETH,
		Want: DAI,
		SlippageLimit: 10%,
		Amount: 1000ETH,
		Relayer: 0xabc...,
		FeesIn: DAI,
		TargetDEX: Uniswap,
		Deadline: time.Now() + 1*time.Minute
		Signature: sign(order.SignBytes())
	},
	{
		Give: DAI,
		Want: ETH,
		SlippageLimit: 1%,
		Amount: 10ETH,
		Relayer: 0xabc...,
		FeesIn: DAI,
		TargetDEX: SushiSwap,
		Deadline: time.Now() + 1*time.Minute
		Signature: sign(order.SignBytes()),
		IsCandyShop: true,
		TransferProfitTo: transactions[0].signer
	}
]
```

The arbitrage profit generated by second order is sent to the `msg.sender` of the first order. The first order will still lose 5%(assumption) in slippage but that will be lower than just sending the order to network as it will have some subsidy from arb profits. Arbitrage profits will rarely be more than the slippage loss.

If someone front runs the transaction sent by the relayer:

1. They pay for the gas while post confirmation of transaction the fees for order1 goes to the relayer in the signed order.
2. They lose 5% in slippage as our real user does.

The thing to note is: **This transaction doesn't result in net +ve it results in less -ve.**

Another thing to note is the order states where to direct the profits, so anyone frontrunning will also have to direct the profits at that address.

We can also deploy `grim-trigger` like strategies, but they have some obvious edge-cases.
